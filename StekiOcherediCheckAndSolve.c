/*
Задача:
Задано арифметическое выражение в обратной польской записи
Проверьте правильность записи и найдите значение выражения.

В этом файле выполняется ввод и проверка обратной польской записи, а также вычисление введённого мат. выражения.

Власов Евгений ИВТ-13БО.

*/

#include <stdio.h>
#include <stdlib.h>
#define _CRT_SECURE_NO_WARNINGS
#define N 50
#define M 2

//Функция ввода и проверки обратной польской записи.
int* EnteringAndCheckingNotation(int n) {
	//Массив с цифрами.
	float A[N];
	//Массив с математическими символами.
	char B[N];
	//Считывание первого числа выражения
	//Это нужно потому, что первые 2 числа могут быть разных размеров, но их нужно как-то отличать. Например, 1234
	printf_s("1-st number of notation: ");
	if (!scanf_s("%f", &A[0])) {
		printf_s("Wrong number\n");
		system("pause");
		exit(0);
	}
	//Присваиваем значение первым двум эл-там массива B[N], т.к. они нигде не исп.
	B[0] = '.';
	B[1] = '.';
	//Ввод обратной польской записи.
	printf_s("Reverse Polish notation: ");
	int i = 1;
	while (i < n) {
		//Считывание цифры.
		if (!scanf_s("%f", &A[i])) {
			printf_s("Wrong number\n");
			system("pause");
			exit(0);
		}
		//Каждый чётный элемент не исп. => он =0.
		i++;
		A[i] = 0;
		//Считывание символа.
		if (!scanf_s("%c", &B[i])) {
			printf_s("Wrong symbol\n");
			system("pause");
			exit(0);
		}
		//Если это нужный мат. символ, то считываем и каждый нечётный символ не исп. => он ='.',
		//иначе ошибка символа и выход из программы.
		if (B[i] == '+' || B[i] == '-' || B[i] == '*' || B[i] == '/') {
			i++;
			B[i] = '.';
			continue;
		}
		else {
			printf_s("Wrong symbol\n");
			system("pause");
			exit(0);
		}
	}

	/*
	int e = SolveNotation(&A, B, n);
	return;
}
int* SolveNotation(float A[N], char B[N], int n) {
*/

//C[N] - стек, который хранит числа для мат. операций.
	float C[N];
	//Переменная a - итоговый ответ.
	float a = 0;
	//Инициализируем массив C[N] с запасом для последующей с ним работы.
	for (int i = 0; i <= n + 1; i++)
		C[i] = 0;
	//Сначала умножаем и делим, т.к. эти операции имеют больший приоритет.
	for (int i = 2; i < n; i = i + 2) {
		if (B[i] == '*') {
			//Если слева есть промежуточный ответ, то перемножить и новый пром. ответ.
			if (C[i - 2] != 0) {
				C[i] = a * A[i - 1];
				a = C[i];
			}
			//Если слева нет промежуточного ответа и это не первый знак, то перемножить и новый пром. ответ.
			if (C[i - 2] == 0 && B[i - 2] != '.') {
				C[i] = A[i - 3] * A[i - 1];
				a = C[i];
			}
			//Если слева нет промежуточного ответа и это первый знак, то перемножить и новый пром. ответ.
			if (C[i - 2] == 0 && B[i - 2] == '.') {
				C[i] = A[i - 2] * A[i - 1];
				a = C[i];
			}
		}
		if (B[i] == '/') {
			//Если получится деление на 0, то предупреждение и завершение работы программы.
			if (A[i - 1] == 0) {
				printf_s("You can't divide by 0");
				system("pause");
				exit(0);
			}
				//Если слева уже есть промежуточный ответ, то поделить и новый пром. ответ.
			if (C[i - 2] != 0) {
				C[i] = a / A[i - 1];
				a = C[i];
			}
				//Если слева есть промежуточный ответ и это первый знак, то разделить и новый пром. ответ.
			if (C[i - 2] == 0 && B[i - 2] != '.') {
				C[i] = A[i - 3] / A[i - 1];
				a = C[i];
			}
				//Если слева нет промежуточного ответа и это первый знак, то разделить и новый пром. ответ.
			if (C[i - 2] == 0 && B[i - 2] == '.') {
				C[i] = A[i - 2] / A[i - 1];
				a = C[i];
			}
		}
	}

	//Теперь складываем и вычитаем, т.к. эти операции имеют меньший приоритет.
	for (int i = 2; i < n; i = i + 2) {
		if (B[i] == '+') {
			//Если это не первый символ.
			if (B[i - 2] != '.') {
				//Если пром. ответ дальше диапазона C[i +- 2], то
				if (C[i - 2] != 0 && C[i + 2] != 0 && C[i - 2] != a && C[i + 2] != a) {
					//k - коэффициент для проверки прохода условия в цикле, j - независимый индекс.
					int k = 0, j = i;
					//Если пром. ответ нах. справа и до '+' или '-', то складываем и новый пром. ответ.
					for (int j = i + 2; B[j - 1] != '+' && B[j - 1] != '-' && j < n; j++) {
						if (C[j] == a) {
							C[i] = C[i - 2] + a;
							a = C[i];
							k++;
							break;
						}
					}
					//Если пром. ответ нах. слева и до '+' или '-', то складываем и новый пром. ответ.
					for (int j = i - 2; B[j + 1] != '+' && B[j + 1] != '-' && j >= 0; j--) {
						if (C[j] == a) {
							C[i] = C[i + 2] + a;
							a = C[i];
							k++;
							break;
						}
					}
					//Если пром. ответа не нашлось, то складываем и новый пром. ответ.
					if (k == 0) {
						C[i] = C[i - 2] - C[i + 2];
						a = C[i];
					}
				}
				//Если справа ничего нет и пром. ответ нах. слева, то складываем и новый пром. ответ.
				if (C[i - 2] != 0 && C[i + 2] == 0) {
					C[i] = a + A[i - 1];
					a = C[i];
				}
				//Если слева ничего нет и пром. ответ нах. справа, то складываем и новый пром. ответ.
				if (C[i - 2] == 0 && C[i + 2] != 0) {
					C[i] = A[i - 1] + a;
					a = C[i];
				}
				//Если с обоих сторон есть числа и пром. ответ нах. слева, то складываем и новый пром. ответ.
				if (C[i - 2] != 0 && C[i + 2] != 0 && C[i - 2] == a) {
					C[i] = a + A[i - 1];
					a = C[i];
				}
				//Если с обоих сторон есть числа и пром. ответ нах. справа, то складываем и новый пром. ответ.
				if (C[i - 2] != 0 && C[i + 2] != 0 && C[i + 2] == a) {
					C[i] = A[i - 1] + a;
					a = C[i];
				}
			}
			//Если это первый символ.
			else {
				//Если справа ничего нет, то складываем и новый пром. ответ.
				if (C[i + 2] == 0) {
					C[i] = A[i - 2] + A[i - 1];
					a = C[i];
				}
				//Если справа есть число, но не пром. ответ, то складываем и новый пром. ответ.
				if (C[i + 2] != a && C[i + 2] != 0) {
					C[i] = A[i - 2] + a;
					a = C[i];
				}
				//Если справа пром. ответ, то складываем и новый пром. ответ.
				if (C[i + 2] == a) {
					C[i] = a + A[i - 2];
					a = C[i];
				}
			}
		}
		if (B[i] == '-') {
			//Если это не первый символ.
			if (B[i - 2] != '.') {
				//Если пром. ответ дальше диапазона C[i +- 2], то
				if (C[i - 2] != 0 && C[i + 2] != 0 && C[i - 2] != a && C[i + 2] != a) {
					//k - коэффициент для проверки прохода условия в цикле, j - независимый индекс.
					int k = 0, j = i;
					//Если пром. ответ нах. справа и до '+' или '-', то вычитаем и новый пром. ответ.
					for (int j = i + 2; B[j - 1] != '+' && B[j - 1] != '-' && j < n; j++) {
						if (C[j] == a) {
							C[i] = C[i - 2] - a;
							a = C[i];
							k++;
							break;
						}
					}
					//Если пром. ответ нах. слева и до '+' или '-', то вычитаем и новый пром. ответ.
					for (int j = i - 2; B[j + 1] != '+' && B[j + 1] != '-' && j >= 0; j--) {
						if (C[j] == a) {
							C[i] = C[i + 2] - a;
							a = C[i];
							k++;
							break;
						}
					}
					//Если пром. ответа не нашлось, то вычитаем и новый пром. ответ.
					if (k == 0) {
						C[i] = C[i - 2] - C[i + 2];
						a = C[i];
					}
				}
				//Если справа ничего нет и пром. ответ нах. слева, то вычитаем и новый пром. ответ.
				if (C[i - 2] != 0 && C[i + 2] == 0) {
					C[i] = a - A[i - 1];
					a = C[i];
				}
				//Если слева ничего нет и пром. ответ нах. справа, то вычитаем и новый пром. ответ.
				if (C[i - 2] == 0 && C[i + 2] != 0) {
					C[i] = A[i - 1] - a;
					a = C[i];
				}
				//Если с обоих сторон есть числа и пром. ответ нах. слева, то вычитаем и новый пром. ответ.
				if (C[i - 2] != 0 && C[i + 2] != 0 && C[i - 2] == a) {
					C[i] = a - A[i - 1];
					a = C[i];
				}
				//Если с обоих сторон есть числа и пром. ответ нах. справа, то вычитаем и новый пром. ответ.
				if (C[i - 2] != 0 && C[i + 2] != 0 && C[i + 2] == a) {
					C[i] = A[i - 1] - a;
					a = C[i];
				}
			}
			//Если это первый символ.
			else {
				//Если справа ничего нет, то вычитаем и новый пром. ответ.
				if (C[i + 2] == 0) {
					C[i] = A[i - 2] - A[i - 1];
					a = C[i];
				}
				//Если справа есть число, но не пром. ответ, то вычитаем и новый пром. ответ.
				if (C[i + 2] != a  && C[i + 2] != 0) {
					C[i] = A[i - 2] - a;
					a = C[i];
				}
				//Если справа пром. ответ, то вычитаем и новый пром. ответ.
				if (C[i + 2] == a) {
					C[i] = a - A[i - 2];
					a = C[i];
				}
			}
		}
	}
	//Вывод ответа.
	printf_s("Answer: %.3f\n", a);
	system("pause");
	return;
}